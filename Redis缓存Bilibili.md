### 一、如何使用缓存

1. 查询redis比查询数据库快
2. 减轻数据库压力

### 二、缓存穿透问题

1. 查询数据库、缓存中都没有的数据时：每次都会查询数据库，没有减轻数据库的压力。 

   1. 解决方法：①缓存空对象：代码简单，效果不好。②布隆过滤器：代码复杂，效果很好。

      1. 缓存空对象：查询数据库也没有拿到数据时，将一个**空对象**也要放进缓存，在刚开始判断数据在缓存中如果不为空的时候，要再加一次判断，如果是**空对象**，则直接返回*没查到*。

         这样解决的是 1 个key ，多次访问的问题。也会导致 redis 中会存在大量无用数据。

      2. 布隆过滤器：

         布隆过滤器是一个集合对象，只有两个方法 put & mightContain，不能更新或删除
         
         1. 布隆过滤器的应用： test/com.local.redisbilibili.TestBloomFilter
         
         2. 布隆过滤器的原理：
         
            底层实现依赖于一个bit(位)数组，初始化全部为0，当存入一个值时，会用hash算法进行计算（hash算法不一定有几个，都是不同的hash函数，可以自己设定hash函数），计算完之后，使用计算结果（数字）对bit数组进行取余，将结果对应的bit数组的下标值修改为1，有几个hash算法，则会有几个下标改为1。
         
         3. 手动实现一个分布式的布隆过滤器：
         
            使用 Redis 的特性，实现一个布隆过滤器。java/com.local.redisbilibili.filter.RedisBloomFilter

Redis 在执行 set [key] [value] 时，value会转换成一个bit数组，来保存value信息。

我们要利用这个bit数组来做布隆过滤器，在 Redis 中，我们set [key] [value] 会保存一个键值信息， 还可以调用setbit [key] [subscript(下标)] [0/1] 来设定 key 所对应的 value 的指定下标位的值，如果这个value原本的长度不足下标长度，则会在原来的 value 所占的位数组的长度的基础上向后扩容，到指定下标位长度，并将这个下标位的长度修改为指定值（0或1），其他中间位均使用0来占位，我们可以直接使用 setbit API 来直接创建一个全0的位数组，这个在 Redi s中被称为位图。

#### 2.1.② 为什么说布隆过滤器复杂呢？

​	在实现布隆过滤器后，在使用方面，应该在程序启动时，将请求所请求的数据库列的值保存在布隆过滤器中，这解决了第一步问题；

​	但是如果添加数据后，向数据库中添加数据的同时，也应该向布隆过滤器中添加对应列的值，不然布隆过滤器会将新添加的数据排除在外；

​	如果一次删除了较为大量的数据库信息时，因为布隆过滤器没有删除的方法，在此时我们应该考虑，重新初始化布隆过滤器。一般使用定时任务来做这个。

### 三、热点数据的处理问题

1. 缓存击穿 

   某一条数据失效，但是发生了并发访问。

   1. 数据库有数据，但缓存没有（数据没有被人访问过）
   2. 数据刚好失效，刚好下一个人去访问

2. 热点数据的处理

   在同一时间多个请求同时请求同一个数据，而这条数据刚好缓存中不存在，那么此时，所有的请求，都会去查询数据库，而且查询的都是同一条数据，会造成数据库的崩溃。

   解决方法：

   ​	在第一次查询缓存后，加入分布式锁（使用分布式锁是因为力度小，我们只需要锁住当前这一条数据就可以），然后再次查询缓存，最后再查询数据库。

   ​	请求 “1” 这条数据执行过程：

   ​		第一个请求进入，查询布隆过滤器，合法数据，继续查询缓存，此时缓存中没有这条数据，分布式锁打开，其他请求被堵塞，第一个请求再次查询缓存，依然不存在，此时查询数据库，拿到数据，加入缓存中，释放分布式锁，返回前端，然后第二个请求获得锁，查询缓存，此时数据存在，从缓存中拿取数据，直接返回前端，其他后面的请求执行过程与第二个请求相同...

### 四、缓存雪崩

1. redis服务器挂了

2. 大部分数据失效

   规避雪崩的方法：

   1. redis 搭建高可用集群解决情况1
   2. 把数据的失效时间错开
   3. 出现了雪崩时：降级 / 熔断

### 五、数据不一致问题 

1. 情况1

![数据库一致性情况1](\数据库一致性情况1.png)

​	2. 情况2

![数据库一致性情况2](\数据库一致性情况2.png)

​	3. 情况3

![数据库一致性情况3](\数据库一致性情况3.png)



​	4. 解决方案1

![数据库一致性解决方案1](\数据库一致性解决方案1.png)·

该解决方案要保证第五步一定执行成功。

使用延时消息队列，并且是确认机制的执行，如果第一次失败，再尝试几次，如果失败，则记录日志，需要运维人员手动处理。

	5. 解决方案2

![数据库一致性解决方案2](\数据库一致性解决方案2.png)





